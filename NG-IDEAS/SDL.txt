Revised "SDL" code, combined SDL1 and SDL2 reimplementation, known as SDL1half until a better name can be given.

- Full C++ implementation, rather than SDL-style plain C
- C++ object for a window
- C++ object for a surface
- Surface attachment to a window
- Surface attachment to a region on a window
- Multiple surfaces can be attached to a window, overlapping allowed
- Surfaces can have child surfaces, and can be reparented (i.e. OpenGL as render to texture instead of to screen)
- Surfaces can scale, but not rotate (in order to help software renderer performance)
- Windows can be directed to go fullscreen (which locks out other windows)
- Library will indicate if environment cannot support multiple windows (i.e. fullscreen, or framebuffer display without windowing system)
- Surface updates can be queued to a window at a frame rate
- Surface output queue can also contain callback events i.e. to ensure smooth animation

- Surface format implementation:
  - First: 32-bit 8-bit RGBA (or ARGB or BGRA, etc) with or without alpha channel
  - Second: 16-bit 5:6:5 RGB or BGR or 5:5:5 XRGB or XBGR
  - Third: 32-bit 10-bit RGBA (or ARGB, etc) without alpha channel
  - 24bpp and 8-bit paletted will NOT be supported
- Surface format conversion support:
  - 8-bit paletted to screen surface
  - 16-bit RGB to screen surface (15/16-bit) RGB/BGR
  - 24-bit RGB to screen surface RGB/BGR
  - 32-bit RGB to screen surface RGBA/RGBX/BGRA/BGRX/XBGR/etc
- Render backends to accomplish this:
  - Pure software
    - Generic integer
    - MMX
    - SSE2
    - AVX
    - AVX2
    - AVX512
  - OpenGL
  - Direct3D9/10/11/12
  - Vulkan
  - Metal (OS X)
- DOSBox-Xng arranges content by describing layout and using compositor rather than
  directly drawing on the overall SDL surface. This way, there is no longer any need
  to write duplicate code for SDL surface vs OpenGL.

- Menu API, for native menu support on OSes that provide it i.e. Windows and Mac OS X, or at minimum a structure to support C++ menu objects
- For OSes that do not provide menus, DOSBox-X can use compositing engine to draw it's own menus

- Monitor API
  - To determine virtual desktop resolution
  - To determine monitors and their place on the virtual desktop
  - To determine the primary monitor
  - To determine the DPI (if available) of each monitor
  - To allow C++ window objects to determine what monitor they are on (which one the majority of it's area exists on)
  - Provide callback (if possible) when a window is moved from one monitor to another
  - Provide callback when monitor resolution changes
  - Provide callback when monitors are added, removed, reconfigured (placement and size), and display depth changes

- Keyboard API
  - Common scan code enum, unambiguous and capable of supporting foreign keyboard layout
  - Keyboard layout determination (no support for changing layout, that's up to the user)
  - Identification of multiple keyboards?
  - API (if possible, and enabled) to read/control Num lock, Caps lock, Scroll lock, etc. LEDs on the keyboard
  - API to read host OS state of num, caps, scroll, etc.
  - Keyboard capture (tied to a C++ window object)

- Input Method Editor support (?)
  - Something to allow the host IME to interact with DOSBox-Xng while not interfering with emulation

- Terminal API
  - Function to determine if a terminal is available, can be opened, is open
  - Function to open a terminal window
  - Function to close a terminal window
  - Function to write to the terminal window
  - If terminal is not VT100 compatible, then terminal API should emulate VT100

